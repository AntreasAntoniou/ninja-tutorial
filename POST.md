# A short and usage-oriented introduction to the Ninja build system

## Introduction

### What is the Ninja build system? 

As with most things, it can be useful to start with the official definition. 
A quick look at the [official Github repository for Ninja](https://github.com/ninja-build/ninja), yields:

> Ninja is a small build system with a focus on speed. 

Reading this definition, many questions come to mind such as: What is a build system? What speed are we referring to? 

While we'll address such questions later in the article, let's first jump straight to some key facts about Ninja, in order to begin to understand what it is and how it works.

It differs from other build systems in two major respects:

1. It is designed to have its input files generated by a higher-level build system such as CMake or Meson.
2. It is designed to run builds as fast as possible. This philosophy even goes into the default arguments which are designed to give you the most performance with little to no tinkering. An example of this is ensuring that by default it builds things in parallel, therefore motivating developers to ensure that their code can be build in parallel, and any problems with doing so, showing up early in the development process. 
3. Ninja shines when it comes to incremental* (or no op) builds. This is because it only rebuilds the files that have changed, and not the entire project. The predecessor to Ninja, Make, on the other hand, rebuilds the entire project every time.

\* Incremental builds refer to builds where a developer is developing each new file/feature one by one and doing many builds in a short period of time. Hence, the build system should only rebuild the files that have changed, and not the entire project. 

It was originally developed partly due to the needs of building large projects such as Google Chrome, by [Evan Martin](https://github.com/evmar), a Google dev.

### What we'll learn in this article

1. What is a build system?
2. What is Ninja?
3. Pros and cons of Ninja. When should you use it, and when should you not?
4. How to install Ninja on your system.
5. How to use Ninja to build a simple C++ project.

## What is a build system?

Software projects are usually composed of many files, and the process of compiling, linking, copying, structuring, 
testing or more generally processing these files into an executable program is called a build.

Generally speaking, build systems fall into two categories:

1. **Build generators**: Software that take as input a spec file written in a specially designed language
 (in many cases Turing complete programming languages), and generates a build file, that tells build tools 
how to go about building a software package. 
2. **Build tools**: Software that take in a build file, previously generated by a build generator and then build 
a software package.

For a more thorough explanation of build systems, check out this [article](https://devopsonwindows.com/what-makes-a-build-system/).

## What is Ninja?

Ninja is a build tool that is designed to be fast, and to be used as a build tool for other build generators.

In other words it falls into category 2. from the previous section. 

### History of Ninja

Ninja was originally developed by Evan Martin, a Google dev, as a resource to speed up building of the projects he was working on, such as Google Chrome. The initial version was apparently hacked together over a weekend, and designed to work with Blaze, a build system developed by Google (the closed source version of Bazel). 

Since then it has been adopted by many other majour projects such as:

- Chrome, which eventually stopped using all other build systems and switched to Ninja.
- Android, which uses Ninja as a large part of its packaging system.
- All Meson projects, which is quickly becoming the golden standard for building open source projects.
- Swift, which even goes as far as to list it as the main way with which to build the project in its documentation.
- LLVM, which uses Ninja as its main build system, and is now one of the main ways Linux is built.

For a very interesting review/tech analysis of the Ninja build system, look at this critical review [article](https://neugierig.org/software/blog/2020/05/ninja.html) of the original author 8 years after its creation. 

### When should I use Ninja, and when should I not?

#### Strengths:
The main strength of Ninja is its speed when it comes to incremental builds. However, the 'speedy' philosophy of Ninja, doesn't stop there. It is designed from the ground up to incentivize developers to write code that can be built in parallel, using defaults that are utilizing the -jN flag which causes Ninja to build in parallel. Furthermore, Ninja does not run using a background Daemon which is constantly keeping track of things in memory, and instead is always starting its own binary from scratch and working without relying on any state. This means that developers will always have a realistic time of build time, without fancy background optimizations done by Daemons, and also makes Ninja more portable and simple.

For a benchmark article on Ninja please have a look at this [article](https://david.rothlis.net/ninja-benchmark/).

For those that skipped the above link, here are the two key figures:

##### Figure 1 - Fresh Build: Ninja vs Make

![Fresh Build: Make vs Ninja](https://david.rothlis.net/ninja-benchmark/fresh-build.png)

##### Figure 2 - Incremental (No OP) Build: Ninja vs Make

![Incremental Build: Make vs Ninja](https://david.rothlis.net/ninja-benchmark/no-op-build.png)

Ninja performs as well as Make in the fresh build, but outperforms it in the incremental build by what appears to be an exponentially increasing factor.

#### Weaknesses:

Ninja is not a build generator. It cannot build projects without a build file, and therefore always needs to work in conjunction with a build generator. CMake and Meson are the most popular build generators that work with Ninja.

With this there are also problems that leak in from the build generators used. If the build generator requires each file to be specified in the build file, such as Make, then the process of writing such build files becomes extremely complicated, time-consuming and error-prone. So the key is to choose the right build generator that works well with Ninja. 

Read more about Bazel in this [article](https://bazel.build/about/faq).


#### When should you use Ninja?

- When you are working on a large project that has many files, and you are doing many incremental builds in a short period of time.
- If you are already using Make, Meson, or CMake to generate build files, and then using Make to build them, Ninja is a plug and play replacement that will at worst keep the performance the same, and at best improve it in an exponential manner in the incremental build case.

#### When should you not use Ninja?

If you want an end-to-end tool (build generator + tool in one) that has a high level language to describe relationships between files and is also a build tool, something like Bazel might be for you. However, Bazel is often slower than Ninja, and is not as portable as Ninja.

For a more thorough comparison of build systems, check out these articles: [article1](https://www.incredibuild.com/blog/top-7-open-source-c-build-systems), [article2](https://nalys-taas-projects.gitlab.io/internal/taas_blog/post/bazel_vs_make/) and this blog-post .

## How to install Ninja on your system

The [Ninja Github page](https://github.com/ninja-build/ninja) might prove very useful to you from now on. The [Wiki page](https://github.com/ninja-build/ninja/wiki) also includes a list of standard build patterns and build generators that work well with Ninja.

### Installing Ninja on Linux:

Depending on the Linux flavour the installation process differs a bit.

- Arch: `pacman -S ninja`
- Debian/Ubuntu: `apt-get install ninja-build`
- Fedora: `dnf install ninja-build`
- Gentoo: `emerge dev-util/ninja`
- Opensuse: `zypper in ninja`
- Alpine: `apk add ninja`

### Installing Ninja on Mac OS:

You can use either homebrew or macports to install it with a one liner on Mac OS.

- HomeBrew: `brew install ninja`
- MacPorts: `port install ninja`

### Installing Ninja on Windows:

You can use either chocolatey or scoop to install it with a one liner on Windows.

- Chocolatey: `choco install ninja`
- Scoop: `scoop install ninja`


### Installing Ninja via package managers:

- Conda: `conda install -c conda-forge ninja`
- Pip: `python -m pip install ninja`
- Spack: `spack install ninja`

### Build Ninja from source:

```bash
git clone git://github.com/ninja-build/ninja.git && cd ninja
git checkout release
```


```bash
./configure.py --bootstrap
```
This will generate the ninja binary and a build.ninja file you can now use to build Ninja with itself.

```bash
cmake -Bbuild-cmake
cmake --build build-cmake
```

The ninja binary will now be inside the build-cmake directory (you can choose any other name you like).

To run the unit tests:
```bash
./build-cmake/ninja_test
```

## Creating and building a project with Ninja

### Creating a project with Ninja

We have created a sample project at https://github.com/AntreasAntoniou/ninja-tutorial.

This tutorial includes a simple 'from-scratch' project as well as one 'incremental' project to demonstrate time-saving features of Ninja.

So let's get started!

1. Clone the repository: `git clone https://github.com/AntreasAntoniou/ninja-tutorial.git`
2. Navigate to the project: `cd ninja-tutorial`
3. Navigate to the 'from-scratch' project: `cd scratch`
4. Notice the two files inside this folder hello_world.cpp and CMakeLists.txt

hello_world.cpp is a simple C++ program that prints "Hello World!" to the console.
```C++
// C++ program to display "Hello World"

// Header file for input output functions
#include <iostream>
using namespace std;

// Main() function: where the execution of program begins
int main()
{
    // prints hello world
    cout << "Hello World";

    return 0;
}
```
CMakeLists.txt is a CMake file that describes the project and how to build it.

```CMake
cmake_minimum_required (VERSION 3.8)

project(HelloWorld CXX)
set(CMAKE_CXX_STANDARD 14)

add_executable(HelloWorld hello_world.cpp)
```

4. 
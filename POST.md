# Using Ninja Build to Build Projects Faster

Ninja is a compact build system with a focus on speedy incremental builds. Essentially, if you are currently developing a software system and you require a rebuild every few minutes to test your latest feature/code-block, then Ninja will only rebuild what you have just modified/added, and nothing else, as opposed to Make, which would rebuild the whole project every single time.

It differs from other build systems in two major ways: It's designed to have its input files generated by a higher-level build system such as CMake or Meson, and it's designed to run builds as fast as possible. This philosophy even goes into the default arguments, which are designed to provide the best performance with little to no tinkering. For example, it builds things in parallel by default, therefore motivating developers to ensure that their code can be built in parallel, and any problems caused by this show up early in the development process. 

It was originally developed by [Evan Martin](https://github.com/evmar), a Google dev, partly in response to the needs of building large projects such as Google Chrome.

This article first explains build systems in a little more detail before introducing Ninja and exploring how to use Ninja to build a simple C++ project.

## What is a Build System?

Software projects are usually composed of many files, and the process of compiling, linking, copying, structuring, testing, or more generally processing these files into an executable program is called a build.

Generally speaking, build systems fall into two categories:

1. **Build generators**: Software that take as input a spec file written in a specially designed language
 (in many cases Turing complete programming languages), and generates a build file, that tells build tools 
how to go about building a software package. 
2. **Build tools**: Software that take in a build file, previously generated by a build generator and then build a software package. Ninja is an example of a build tool.

For a more thorough explanation of build systems, check out this [article](https://devopsonwindows.com/what-makes-a-build-system/).

## What is Ninja?
Ninja is a fast build tool that can also be used as a build tool for other build generators. As mentioned, it was originally developed by Evan Martin, a Google dev, as a resource to speed up the building of projects such as Chrome. Since its inception, some notable projects built using Ninja include Chrome, Android, all Meson projects, Swift, and LLVM. For a very interesting review and tech analysis of the Ninja build system, look at this critical review [article](https://neugierig.org/software/blog/2020/05/ninja.html) written by Ninja's creator eight years after its original release. 
## Ninja's Strengths and Weaknesses
The main strength of Ninja is its speed in incremental builds. It incentivizes developers to write code that can be built in parallel, using defaults that utilize the -jN flag, which causes Ninja to build in parallel. Furthermore, Ninja doesn't use a background Daemon to constantly keep track of things in memory; it always starts its own binary from scratch and works without relying on any state. So, developers will always have a realistic idea of build time without fancy background optimizations done by Daemons, and it also makes Ninja very portable and simple.
[According to benchmarks]( https://david.rothlis.net/ninja-benchmark), Ninja performs as well as Make in the fresh build but outperforms it in the incremental build by what appears to be an exponentially increasing factor.
On the downside, Ninja can't build projects without a build file, so it must always work with a build generator, such as CMake and Meson, the most popular build generators that work with Ninja. Problems can be introduced depending on the build generator used. For example, Make requires each file to be specified in the build file, making the process of writing these files extremely complicated, time-consuming, and error-prone. So, the key is to choose the right build generator that works well with Ninja. 
 ### When Should You Use Ninja?
Ninja works well for large projects with many files that need many incremental builds over a short time. If you're already using Make, Meson, or CMake to generate build files and using Make to build them, Ninja is a plug-and-play replacement that will, at worst, keep the performance the same or, at best, improve it in an exponential manner in an incremental build case.
Conversely, Ninja might not be a good choice if you want an end-to-end tool (build generator and tool in one) that has a high-level language to describe relationships between files and is also a build tool. In that case, something like [Bazel](https://bazel.build/) might be better, but it's often slower than Ninja and not as portable.

## Implementing a Ninja Build

The following sections first explain the different ways to install Ninja, before going through step-by-step instructions for implementing a Ninja build.

### How to Install Ninja

This section explains how to install Ninja on Linux, Mac, and Windows and how to build it from source.

For a more thorough set of instructions for any specialized installation cases please see the [Ninja Github page](https://github.com/ninja-build/ninja), which is always a very useful resource in general. For day-to-day use, the [Wiki page](https://github.com/ninja-build/ninja/wiki) also includes a list of standard build patterns and build generators that work well with Ninja.

#### Installing Ninja on Linux

Depending on the Linux flavor the installation process differs a bit:

- Arch: `pacman -S ninja`
- Debian/Ubuntu: `apt-get install ninja-build`
- Fedora: `dnf install ninja-build`
- Gentoo: `emerge dev-util/ninja`
- Opensuse: `zypper in ninja`
- Alpine: `apk add ninja`

#### Installing Ninja on Mac OS

Ninja can be installed using either [homebrew](https://brew.sh) or [macports](https://www.macports.org) with a one liner on Mac OS:

- HomeBrew: `brew install ninja`
- MacPorts: `port install ninja`

#### Installing Ninja on Windows

[Chocolatey](https://chocolatey.org) or [scoop](https://scoop.sh) can be used to install Ninja with a one liner on Windows.

- Chocolatey: `choco install ninja`
- Scoop: `scoop install ninja`


#### Installing Ninja via Package Managers

Ninja can also be installed via package managers that generally provide more convenience when managing multiple other packages in addition to ninja:

- Conda: `conda install -c conda-forge ninja`
- Pip: `python -m pip install ninja`
- Spack: `spack install ninja`

#### Build Ninja From Source

Users who don't want to build Ninja with specialized flags, can build it from source with the following instructions.

First clone and checkout the ninja repo.

```bash
git clone git://github.com/ninja-build/ninja.git && cd ninja
git checkout release
```
Then build a basic ninja binary and a set of files needed to build ninja.

```bash
./configure.py --bootstrap
```
This will generate the Ninja binary and a build.ninja file that can be used to build Ninja with itself. That is, the basic ninja binary generated in the previous step can be used to build the particular configuration of Ninja required. A sort of "ninjaception" if you will.

Use the following code to build ninja:

```bash
cmake -Bbuild-cmake
cmake --build build-cmake
```

The Ninja binary will now be inside the build-cmake directory (though the user can name this directory anything).

The following code will run the unit tests:

```bash
./build-cmake/ninja_test
```

### Creating a Project With Ninja

To demonstrate how to use Ninja, as well as showcase some of its strengths, this tutorial uses a sample project, which can be found in this [github repo](https://github.com/AntreasAntoniou/ninja-tutorial).

This tutorial demonstrates how to create a simple 'from-scratch' project and an 'incremental' project to demonstrate time-saving features of Ninja.

#### Prerequisites 

The following prerequisites are required for this tutorial:

CMake is required to build the project. Instructions for CMake installation can be found on their [official website](https://cmake.org/install/ to install CMake).
Python is required to generate the sample files used in this tutorial. Ensure python is installed before proceeding. This can be done by following the instructions in this [Installation Guide](https://realpython.com/installing-python/).

For Linux users, CMake can be installed with the single terminal command `sudo snap install cmake --classic` and on Mac-OS with `brew install cmake`.

#### Creating a Project From Scratch

To create a project from scratch, do the following:

1. Clone the repository: `git clone https://github.com/AntreasAntoniou/ninja-tutorial.git`
2. Navigate to the project: `cd ninja-tutorial`
3. Navigate to the 'from-scratch' project: `cd scratch`
4. Notice the two files inside this folder `hello_world.cpp` and `CMakeLists.txt`

`hello_world.cpp` is a simple C++ program that prints "Hello World!" to the console:

```C++
// C++ program to display "Hello World"

// Header file for input output functions
#include <iostream>
using namespace std;

// Main() function: where the execution of program begins
int main()
{
    // prints hello world
    cout << "Hello World";

    return 0;
}
```

`CMakeLists.txt` is a CMake file that describes the project and how to build it:

```CMake
cmake_minimum_required (VERSION 3.8)

project(HelloWorld CXX)
set(CMAKE_CXX_STANDARD 14)

add_executable(HelloWorld hello_world.cpp)
```

Now use CMake to generate a build file for Ninja:

```bash
cmake -G Ninja
```

This should generate a build.ninja file in the current directory, along with related configuration files.

Now the project can built with Ninja using the following command:

```bash
ninja
```

The following output should be generated:

```
[2/2] Linking CXX executable HelloWorld
```

With that, the Ninja project should have been successfully built.

#### Creating and Building An Incremental Project

Now, go back to the root of the repository and navigate to the 'incremental' project by running:

```bash
cd ..
cd incremental
```

There are three files here: `hello_world-template.cpp`, `CMakeLists-template.txt`, and `generate_project_files.py`.

The `generate_project_files.py` script is a Python script that generates the C++ project files and the CMake file from the template files.

This script needs to be run twice, once to generate a 1000 file project and a second time to generate a 1001 file project. So, the second project will be an incremental build of the first.

Generate the 1000 file project first:

```bash
python3 generate_project_files.py --num_files 1000
```

Now, use CMake to generate a build file for Ninja:

```bash
cmake -S sample_project -G Ninja
```

This should generate a build.ninja file in the current directory, along with related configuration files.

Build the project with Ninja:

```bash
ninja
```

Next, emulate an incremental build by adding one more file to our sample project:

```bash
python3 generate_project_files.py --num_files 1001
```

Use CMake to generate a build file for Ninja:

```bash
cmake -S sample_project -G Ninja
```

This should generate a build.ninja file in the current directory, along with related configuration files.

As before, build the project with Ninja:

```bash
ninja
```

In the second build, Ninja only builds the new file and not the entire project.

This can be seen in the terminal output that shows how many files had to be processed, as well as the time taken for the build to complete.

On the local setup (Apple M1 Max 16 inch) used in this tutorial, the first build took 35 seconds, and the second build took 3 seconds.

The follow is a copy of the terminal output for the second build:

```bash
❯ cmake -S sample_project/ -G Ninja
-- The CXX compiler identification is AppleClang 14.0.0.14000029
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/helloworld/ninja-tutorial/incremental

ninja-tutorial/incremental on  main [!+?] via △ v3.24.2 via 🐍 v3.9.13 on ☁️  took 4s
❯ ninja
[2000/2000] Linking CXX executable HelloWorld998

ninja-tutorial/incremental on  main [!+?] via 🐍 v3.9.13 on ☁️ took 5m54s
❯ python generate_project_files.py --num_files 1001
Done

ninja-tutorial/incremental on  main [!+?] via 🐍 v3.9.13 on ☁️
❯ cmake -S sample_project/ -G Ninja
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/helloworld/ninja-tutorial/incremental

ninja-tutorial/incremental on  main [!+?] via 🐍 v3.9.13 on ☁️ took 3s
❯ ninja
[2/2] Linking CXX executable HelloWorld1000
```

As you can see, Ninja is able to build the updated 1001 file project in only 3 seconds, compared to the 35 seconds it took to build its predecessor project consisting of 1000 files. That’s because Ninja only had to add one more file to the build that had 1001 files, after it had already built the 1000-file variant of the same project.

## Conclusion

This article introduced build systems and Ninja before explaining how to install Ninja and use it to build your C++ projects. 

Tools that help automate the building, testing, and deployment process of software, such as the build systems discussed in this article, are essential to the success of any software project. Ninja is a great tool that can save time and effort when building C++ projects. In the same vein, continuous Integration frameworks that automate the process of building, testing, and deployment are also essential to the success of any software project; once an update is pushed to a repo, the CI framework takes care of the rest.

[Earthly.dev](https://earthly.dev.) is a continuous integration framework with an emphasis on repeatable, language agnostic builds implemented as containers. Its bottom up development philosophy ensures it's easy to understand, even for beginnings, without the need of a ‘Build Guru’ in the team. Its design also prioritizes readability, which is a breath of fresh air, given that this trait does not seem to be a priority for most continuous integration framework.

To learn more about Earthly.dev and how it can help you build, test, and deploy your software projects, try out their [free, open source core version](https://earthly.dev/get-earthly).


The code samples used in the post can be found in this [GitHub repo](https://github.com/AntreasAntoniou/ninja-tutorial).
